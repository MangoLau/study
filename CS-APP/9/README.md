# 第九章 虚拟内存
## 9.1 物理和虚拟寻址
## 9.2 地址空间
## 9.3 虚拟内存作为缓存的工具
### 9.3.1 DRAM缓存的组织结构
### 9.3.2 页表
### 9.3.3 页命中
### 9.3.4 缺页
### 9.3.5 分配页面
### 9.3.6 又是局部性救了我们
## 9.4 虚拟内存作为内存管理的工具
## 9.5 虚拟内存作为内存保护的工具
## 9.6 地址翻译
### 9.6.1 结合高速缓存和虚拟内存
### 9.6.2 利用TLB加速地址翻译
### 9.6.3 多级页表
### 9.6.4 综合：端到端的地址翻译
## 9.7 案例研究：Intel Core i7/Linux 内存系统
### 9.7.1 Core i7地址翻译
### 9.7.2 Linux虚拟内存系统
## 9.8 内存映射
### 9.8.1 再看共享对象
### 9.8.2 再看fork函数
### 9.8.3 再看execve函数
### 9.8.4 使用mmap函数的用户级内存映射
## 9.9 动态内存分配
### 9.9.1 malloc和free函数
### 9.9.2 为什么要使用动态内存
### 9.9.3 分配器的要求和目标
### 9.9.4 碎片
### 9.9.5 实现问题
### 9.9.6 隐式空间链表
### 9.9.7 放置已分配的块
### 9.9.8 分割空闲块
### 9.9.9 获取额外的堆内存
### 9.9.10 合并空闲块
### 9.9.11 带边界标记的合并
### 9.9.12 综合：实现一个简单的分配器
### 9.9.13 显示空闲链表
### 9.9.14 分离的空闲链表
## 9.10 垃圾收集
### 9.10.1 垃圾收集器的基本知识
### 9.10.2 Mark&Sweep垃圾收集器
### 9.10.3 C程序的保守Mark&Sweep
## 9.11 C程序中常见的与内存有关的错误
### 9.11.1 间接引用坏指针
### 9.11.2 读未初始化的内存
### 9.11.3 允许栈缓冲区溢出
### 9.11.4 假设指针和它们指向的对象是相同大小的
### 9.11.5 造成错位错误
### 9.11.6 引用指针，而不是它所指向的对象
### 9.11.7 误解指针运算
### 9.11.8 引用不存在的变量
### 9.11.9 引用空闲堆块中的数据
### 9.11.10 引擎内存泄露
## 9.12 小结