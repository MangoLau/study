# 第三章 程序的机器级表示
## 3.1 历史观点
## 3.2 程序编码
### 3.2.1 机器级代码
### 3.2.2 代码示例
### 3.2.3 关于格式的注解
## 3.3 数据格式
## 3.4 访问信息
### 3.4.1 操作数指示符
### 3.4.2 数据传送指令
### 3.4.3 数据传送示例
### 3.4.4 压入和弹出栈数据
## 3.5 算术和逻辑操作
### 3.5.1 加载有效地址
### 3.5.2 一元和二元操作
### 3.5.3 移位操作
### 3.5.4 讨论
### 3.5.5 特殊的算术操作
## 3.6 控制
### 3.6.1 条件码
### 3.6.2 访问条件码
### 3.6.3 跳转指令
### 3.6.4 跳转指令的编码
### 3.6.5 用条件控制来实现条件分支
### 3.6.6 用条件传送来实现条件分支
### 3.6.7 循环
### 3.6.8 switch语句
## 3.7 过程
### 3.7.1 运行时栈
### 3.7.2 转移控制
### 3.7.3 数据传送
### 3.7.4 栈上的局部存储
### 3.7.5 寄存器中的局部存储空间
### 3.7.6 递归过程
## 3.8 数组分配和访问
### 3.8.1 基本原则
### 3.8.2 指针运算
### 3.8.3 嵌套的数组
### 3.8.4 定长数组
### 3.8.5 变长数组
## 3.9 异质的数据结构
### 3.9.1 结构
### 3.9.2 联合
### 3.9.3 数据对齐
## 3.10 在机器级程序中将控制与数据结合起来
### 3.10.1 理解指针
### 3.10.2 应用：使用GDB调试器
### 3.10.3 内存越界引用和缓冲区溢出
### 3.10.4 对抗缓冲区溢出攻击
### 3.10.5 支持变长栈帧
## 3.11 浮点代码
### 3.11.1 浮点传送和转换操作
### 3.11.2 过程中的浮点代码
### 3.11.3 浮点运算操作
### 3.11.4 定义和使用浮点常数
### 3.11.5 在浮点代码中使用位级操作
### 3.11.6 浮点比较操作
### 3.11.7 对浮点代码的观察结论
## 3.12 小结