## 6.1 为什么查询速度会慢

## 6.2 慢查询基：优化数据访问
对低效查询的分析：
1. 确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。
2. 确认MySQL服务器层是否在分析大量超过需要的数据行。

### 6.2.1 是否向数据库请求了不需要的数据
- 查询不需要的数据
- 多表关联时返回全部列
- 总是取出全部列
- 重复查询相同的数据

### 6.2.2 MySQL是否在扫描额外的记录
最简单的衡量查询开销的三个指标如下：
- 响应时间
- 扫描的行数
- 返回的行数

#### 响应时间
服务时间和排队时间之和。
服务时间：指数据库处理这个查询真正花了多长时间。
排队时间：指服务器因为等待某些资源而没有真正执行查询的时间。

#### 扫描的行数和返回的行数

#### 扫描的行数和访问类型

## 6.3 重构查询的方式
### 6.3.1 一个复杂查询还是多个简单查询
### 6.3.2 切分查询
### 6.3.3 分解关联查询
优势：
- 让缓存的效率更高
- 将查询分解后，执行单个查询可以减少锁的竞争。
- 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
- 查询本身效率也可能有所提升。
- 可以减少冗余记录的查询。
- 更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。

## 6.4 查询执行的基础
当向MySQL发送一个请求时，MySQL到底做了什么：
1. 客户端发送一条查询给服务器。
2. 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。
3. 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。
4. MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。
5. 将结果返回给客户端。

### 6.4.1 MySQL客户端/服务器通信协议
#### 查询状态
- sleep
线程正在等待客户端发送新的请求。
- query
线程正在执行查询或者正在将结果发送给客户端。
- locked
在MySQL服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如InnoDB的行锁，并不会体现在线程状态中。对于MyISAM来说这是一个比较典型的状态，但在其它没有行锁的引擎中也经常会出现。
- Analyzing and statistics
线程正在收集存储引擎的统计信息，并生成查询的执行计划。
- Copying to tmp table [on disk]
线程正在执行查询，并且将其结果都复制到一个临时表中，这种状态要么时在做group by操作，要么时文件排序操作，或者时union操作。如果这个状态后面还有“on disk”标记，那表示MySQL正在将一个内存临时表放到磁盘上。
- Sorting result
线程正在对结果集进行排序。
- Sending data
这表示多种情况：线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。

### 6.4.2 查询缓存

### 6.4.3 查询优化处理
#### 语法解析器和预处理
#### 查询优化器
MySQL能够处理的优化类型：
- 重新定义关联表的顺序
- 将外连接转化成内连接
- 使用等价变换规则
- 优化COUNT()、MIN()、和MAX()
- 预估并转化为常数表达式
- 覆盖索引扫描
- 子查询优化
- 提前终止查询
- 等值传播
- 列表IN()的比较

#### 数据和索引的统计信息
#### MySQL如何执行关联查询
#### 执行计划
#### 关联查询优化器
#### 排序优化
MySQL的两种排序算法：
- 两次传输排序（旧版本使用）
- 单次传输排序（新版本使用）

### 6.4.4 查询执行引擎

### 6.4.5 返回结果给客户端

## 6.5 MySQL查询优化器的局限性
### 6.5.1 关联子查询
#### 如何用好关联子查询

### 6.5.2 UNION的限制

### 6.5.3 索引合并优化

### 6.5.4 等值传递

### 6.5.5 并行执行

### 6.5.6 哈希关联

### 6.5.7 松散索引扫描

### 6.5.8 最大值和最小值优化

### 6.5.9 在同一个表上查询和更新
MySQL不允许对同一张表同时进行查询和更新。
```sql
# 错误示例
UPDATE tbl AS outer_tbl
	SET cnt=(
		SELECT count(*) FROM tbl AS inner_tbl
		WHERE inner_tbl.type=outer_tbl.type
	);
```
可以通过使用生成表的形式来绕过上面的限制，因为MySQL只会把这个表当作一个临时表来处理。
```sql
UPDATE tbl
	INNER JOIN(
		SELECT type,count(*) AS cnt
		FROM tbl
		GROUP BY type
	) AS der USING(type)
SET tbl.cnt=der.cnt;
```

## 6.6 查询优化器的提示（hint）
#### HIGH_PROIORITY 和 LOW_PROIORITY
#### DELAYED
#### STRAIGHT_JOIN
#### SQL_SMALL_RESULT 和 SQL_BIG_RESULT
#### SQL_BUFFER_RESULT
#### SQL_CACHE 和 SQL_NO_CACHE
#### SQL_CALC_FOUND_ROWS
#### FOR UPDATE 和 LOCK IN SHARE MODE
#### USING INDEX、IGNORE INDEX 和 FORCE INDEX

## 6.7 优化特定类型的查询
### 6.7.1 优化COUNT(\*)查询
#### COUNT()的作用
可以统计某个列值的数量，也可以统计行数。
如果希望知道的是结果集的行数，最好使用COUNT(\*)，这样写意义清晰，性能也会很好。

#### 关于MyISAM的神话
#### 简单的优化
```sql
#优化前
SELECT COUNT(*) FROM world.city WHERE id>5;
# 优化后
SELECT (SELECT COUNT(*) FROM world.city) - COUNT(*)
FROM world.city WHERE id<=5;
# 这样做可以大大减少需要扫描的行数，是因为在查询优化阶段会将其中的子查询直接当作一个常数来处理。
```

#### 使用近似值
#### 更复杂的优化

### 6.7.2 优化关联查询
- 确保ON或者USING子句中的列上有索引。
- 确保任何的GROUP BY 和 ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。
- 当升级MySQL的时候需要注意：关联语法、运算符优先级等其它可能会发生变化的地方。

### 6.7.3 优化子查询

### 6.7.4 优化GROUP BY 和 DISTINCT
#### 优化GROUP BY WITH ROLLUP

### 6.7.5 优化 LIMIT 分页

### 6.7.6 优化 SQL_CALC_FOUND_ROWS

### 6.7.7 优化UNION查询

### 6.7.8 静态查询分析

### 6.7.9 使用用户自定义变量
不能使用自定义变量的场景：
- 使用自定义变量的查询，无法使用查询缓存。
- 不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名和LIMIT子句中。
- 用户自定义变量的生命周期是在一个连接中有效，所以不能用他们来做连接间的通信。
- 如果使用连接池或者持久化连接，自定义变量可能让看起来毫无关系的代码发生交互（如果是这样，通常是代码bug或者连接池bug，这类情况确实可能发生）。
- 在5.0之前的版本，是大小写敏感的，所以要注意代码在不同MySQL版本间的兼容性问题。
- 不能显示地声明自定义变量的类型。
- MySQL优化器在某些场景下可能会将这些变量优化掉，这可能导致代码不按预想的方式运行。
- 赋值的顺序和赋值的时间点并不总是固定的，这依赖于优化器的决定。
- 赋值符号 := 的优先级非常低，所以需要注意，赋值表达式应该使用明确的括号。
- 使用为定义变量不会产生任何语法错误，如果没有意识到这一点，非常容易犯错。

#### 优化排名语句
使用用户自定义变量的一个重要特性是你可以给一个变量赋值的同时使用这个变量。例：
```sql
SET @rownum=0;
SELECT act_id,@rownum := @rownum + 1 AS rownum
FROM sakila.actor LIMIT 3;
```

#### 避免重复查询刚刚更新的数据
```sql
UPDATE t1 SET lastUpdated=NOW() WHERE id=1 AND @now := NOW();
```

#### 统计更新和插入的数量

#### 确定取值的顺序

##### 编写偷懒的UNION

#### 用户自定义变量的其它用处
- 查询运行时计算总数和平均值。
- 模拟GROUP语句中的函数FIRST()和LAST()。
- 对大量数据做一些数据计算。
- 计算一个大表的MD5三列值。
- 编写一个样本处理函数，当样本中的数值超过某个边界值的时候将其变成0。
- 模拟读/写游标。
- 在SHOW语句的WHERE子句中加入变量值。

## 6.8 案例学习

### 6.8.1 使用MySQL构建一个队列表

### 6.8.2 计算两点之间的距离
优化策略：
- 尽量少做事，可能的话尽量不做事。
- 快速地完成事情。确保在你的设计中尽可能地让查询都用上合适的索引，使用近似计算来避免复杂的计算。
- 需要的时候，尽可能让应用程序完成一些计算。

### 6.8.3 使用用户自定义函数

## 6.9 总结