# 创建高性能的索引
### 5.1.1 索引的类型
- B-Tree索引
- 哈希索引
- 空间数据索引（R-Tree）
- 全文索引
- 其他索引类别

## 5.2 索引的优点
1. 索引大大减少了服务器需要扫描的数据量。
2. 索引可以帮助服务器避免排序和临时表。
3. 索引可以将随机I/O变为顺序I/O。

## 5.3 高性能索引的策略
### 5.3.1 独立的列
是指索引列不能是表达式的一部分，也不能是函数的参数。
### 5.3.2 前缀索引和索引的选择性
### 5.3.3 多列索引
### 5.3.4 选择合适的索引列顺序
### 5.3.5 聚簇索引
### 5.3.6 覆盖索引
### 5.3.7 使用索引扫描来做排序
只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序方向（或正序）都一样时，MySQL才能够使用索引来对结果做排序。
如果查询需要关联多张表，则只有当order by子句引用的字段全部为第一个表时，才能使用索引做排序。
### 5.3.8 压缩（前缀压缩）索引
### 5.3.9 冗余和重复索引
冗余索引要视情况而定。
重复索引必须删除。
### 5.3.10 未使用的索引
建议删除。
### 5.3.11 索引和锁
索引可以让查询锁定更少的行。

## 5.4 索引案例学习
### 5.4.1 支持多种过滤条件
考虑表上所有的选项。当设计索引时，不要只为现有的查询考虑需要哪些索引，还需要考虑对查询进行优化。
尽可能让MySQL使用更多的索引列，因为查询只能使用索引的最左前缀，直到遇到第一个范围条件列。
尽可能将需要做范围查询的列放到索引的后面，以便优化器能使用尽可能多的索引列。
### 5.4.2 避免多个范围条件
### 5.4.3 优化排序
对于选择性非常低的列，可以增加一些特殊的索引来做排序。
对于order by和limit组合翻页到很后面时，反范式化、预先计算

## 5.5 维护索引和表
维护表有三个目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。
### 5.5.1 找到并修复损坏的表
可以尝试运行check table来检查是否发生了表损坏。
可以使用REPAIR TABLE命令来修复损坏的表。也可通过一个不做任何操作的ALTER操作来重建表，例如修改表的存储引擎为当前的引擎。此外也可以使用存储引擎相关的离线工具，例如myiasmchk；或者将数据导出一份，然后重新再导入。不过，如果损坏的事系统区域，或者是表的“行数据”区域，而不是索引，那么上面的办法就没有用了。此时，可以从备份中恢复表，或者尝试从损坏的数据文件中尽可能地恢复数据。

### 5.5.2 更新索引统计信息
可以使用SHOW INDEX FROM命令来查看索引的基数。

### 5.5.3 减少索引和数据的碎片
数据碎片：行碎片；行间碎片；剩余空间碎片。
可以通过OPTIMIZE TABLE或者导出再导入的方式来重新整理数据。对于一些存储引擎如MyISAM，可以通过排序算法重建索引的方式来消除碎片。可以通过一个不做任何操作（no-op）的ALTER TABLE操作来重建表。例：`ALTER TABLE <table> ENGINE=<engine>;`