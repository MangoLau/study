## 7.1 分区表
对用户来说，分区表是一个独立的逻辑表，但是底层有多个物理子层组成。实现分区的代码实际上是对一组底层表的句柄对象（Handler Object）的封装。对分区表的请求，都会通过句柄对象转化成对存储引擎的接口调用。所以分区对于SQL层来说是一个完全封装底层实现的黑盒子，对应用是透明的，但是从底层的文件系统来看就很容易发现，每一个分区表都有一个使用#分隔命名的表文件。

分区表适用场景：
- 表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其它均是历史数据。
- 分区表的数据更容易维护。
- 分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。
- 可以使用分区表来避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问、ext3文件系统的inode锁竞争等。
- 如果需要，还可以备份和恢复独立的分区，这在非常大的数据集的场景下效果非常好。

分区表的限制：
- 一个表最多只能用1024个分区。
- 在MySQL5.1中，分区表达式必须是整数，或者是返回证书的表达式。在MySQL5.5中，某些场景中可以直接使用列来进行分区。
- 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。
- 分区表中无法使用外键约束。

### 7.1.1 分区表的原理

### 7.1.2 分区表的类型

### 7.1.3 如何使用分区表

### 7.1.4 什么情况下会出问题
- NULL值会使分区过滤无效
- 分区列和索引列不匹配
- 选择分区的成本可能很高
- 打开并锁住所有底层表的成本可能很高
- 维护分区的成本可能很高

### 7.1.5 查询优化

### 7.1.6 合并表

## 7.2 视图
### 7.2.1 可更新视图
是指可以通过更新这个视图来更新视图涉及的相关表。

### 7.2.2 视图对性能的影响

### 7.2.3 视图的限制

## 7.3 外键约束

## 7.4 在MySQL内部存储代码

### 7.4.1 存储过程和函数

### 7.4.2 触发器

### 7.4.3 事件

### 7.4.4 在存储程序中保留注释

## 7.5 游标

## 7.6 绑定变量
### 7.6.1 绑定变量的优化

### 7.6.2 SQL接口的绑定变量

### 7.6.3 绑定变量的限制

## 7.7 用户自定义函数

## 7.8 插件

## 7.9 字符集和校对
### 7.9.1 MySQL如何使用字符集
#### 创建对象时的默认设置
#### 服务器和客户端通信时的设置
#### MySQL如何比较两个字符串的大小
#### 一些特殊情况

### 7.9.2 选择字符集和校对规则

### 7.9.3 字符集和校对规则如何影响查询

## 7.10 全文索引

### 7.10.1 自然语言的全文索引

### 7.10.2 布尔全文索引

### 7.10.3 MySQL 5.1中全文索引的变化

### 7.10.4 全文索引的限制和替代方案

### 7.10.5 全文索引的配置和优化

## 7.11 分布式（XA）事务

### 7.11.1 内部XA事务

### 7.11.2 外部XA事务

## 7.12 查询缓存

### 7.12.1 MySQl如何判断缓存命中

### 7.12.2 查询缓存如何使用内存

### 7.12.3 什么情况下查询缓存能发挥作用

### 7.12.4 如何配置和维护查询缓存
- query_cache_type
- query_cache_size
- query_cache_min_res_unit
- query_cache_limit
- query_cache_wlock_invalidate

#### 减少碎片
#### 提高查询缓存的使用率

### 7.12.5 InnoDB和查询缓存

### 7.12.6 通用查询缓存优化

### 7.12.7 查询缓存的替代方案

## 7.13 总结